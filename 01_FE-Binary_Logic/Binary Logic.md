<h1 align="center">🔢 计算机理论核心：二进制与逻辑运算</h1>
<p align="center">
  <b>基本情报技术者考试必修课 | 核心内容完整版</b><br>
  <i>理解计算机的思维方式 | 从 0 与 1 到逻辑电路</i>
</p>

---

## 🏗️ 0. 引言：计算的起点

计算机只能识别 **开 (ON/1)** 和 **关 (OFF/0)** 状态。这种仅使用 0 和 1 表示所有信息的系统就是 **二进制 (2進数)**。

<div align="center">

| 核心单位 | 英文名称 | 换算关系 |
| :--- | :--- | :--- |
| **比特** | Bit (ビット) | 信息的最小单位。 |
| **字节** | Byte (バイト) | **1 Byte = 8 Bit** (最基本单位)。 |

</div>

---

## 📊 1. 数字系统：多进制的架构

### 1.1 核心三要素
任何进制系统都由以下概念构成：
*   **基数**：每个数位可用的符号个数（如十进制为 10）。
*   **位权**：数位所代表的大小，是基数的幂（如 $2^0, 2^1, 2^2 \dots$）。
*   **进位**：逢基数进一（逢二进一、逢十进一）。

### 1.2 常用进制对比

<div align="center">

| 进制系统 | 基数 | 使用符号 | 应用场景 |
| :--- | :--- | :--- | :--- |
| **二进制** | 2 | 0, 1 | 对应电路开关，数据处理基础。 |
| **八进制** | 8 | 0-7 | 简化二进制（2³=8）。 |
| **十进制** | 10 | 0-9 | 人类计数。 |
| **十六进制** | 16 | 0-9, A-F | **最主流**的简化表示法（2⁴=16）。 |

</div>

---

## 🔄 2. 基数转换：进制间的“翻译”

### 2.1 任意进制 → 十进制
**方法**：将每一位数字乘以其对应的位权，然后相加。
> **示例**：$(1011)_2 = 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 8 + 0 + 2 + 1 = \mathbf{11_{10}}$
> **示例**：$(2A)_{16} = 2 \cdot 16^1 + 10 \cdot 16^0 = 32 + 10 = \mathbf{42_{10}}$

### 2.2 十进制 → 任意进制
*   **整数部分**：**除基取余法**（反复除以基数，余数**逆序**排列）。
*   **小数部分**：**乘基取整法**（反复乘以基数，整数**顺序**排列）。

<div align="center">

| 转换案例 | 计算过程简述 | 结果 |
| :--- | :--- | :--- |
| **(10)₁₀ → (binary)** | $10\div2=5\dots0 \dots 1\div2=0\dots1$ | **(1010)₂** |
| **(0.125)₁₀ → (binary)** | $0.125\cdot2=0.25(0) \to 0.25\cdot2=0.5(0) \to 0.5\cdot2=1.0(1)$ | **(.001)₂** |
| **(182)₁₀ → (hex)** | $182\div16=11\dots6 \quad 11\div16=0\dots11(B)$ | **(B6)₁₆** |

</div>

> [!CAUTION]
> **舍入误差 (丸め誤差)**：如 $0.275 \cdot 2$ 这种无法乘清零的分数，会导致精度丢失。

### 2.3 2/8/16 进制快速转换
由于 $8=2^3$ 且 $16=2^4$，可以直接分组转换：
*   **二进制 ↔ 八进制**：每 3 位一组。
*   **二进制 ↔ 十六进制**：每 4 位一组。

> **示例：二进制 $(11010110)_2 \leftrightarrow$ 十六进制**
> 1. 从右往左每 4 位分组：`1101` | `0110`
> 2. 将每组独立转换：
>    * `1101` $\rightarrow 8+4+0+1 = 13$ (即十六进制的 **D**)
>    * `0110` $\rightarrow 0+4+2+0 = 6$ (即十六进制的 **6**)
> 3. 合并结果：$(D6)_{16}$

---

## 🧮 3. 二进制运算：计算的本质

### 3.1 类型区分：无符号 vs 有符号
*   **无符号数 (符号なし)**：所有位均表示数值，范围 $0 \sim 2^n-1$。
*   **有符号数 (符号あり)**：最高位为**符号位**（0 正，1 负）。
    *   负数在计算机内统一使用 **补码 (2's Complement)** 存储。
    *   **优势**：符号位可以像数值位一样参与加法运算，简化硬件设计。

### 3.2 二进制加法
遵循“逢二进一”规则。
> **示例：有符号数补码运算 $5 + (-3)$**
> 1.  **5 的补码**：`0000 0101`
> 2.  **-3 的补码**：`1111 1101` (由 3 取反加 1 得到)
> 3.  **相加**：
>     ```text
>        0000 0101 (5)
>      + 1111 1101 (-3)
>      -----------
>      (1)0000 0010 (结果为 2，最左侧进位丢弃)
>     ```

### 3.3 二进制减法与补数 (Complement)
计算机没有减法电路，减法通过将减数转换为**补数**后进行加法运算。
*   **原码**：最高位符号位，其余数值位。
*   **1 的补数 (反码)**：将二进制位逐位取反。
*   **2 的补数 (补码)**：在反码基础上 **加 1**。
> **核心逻辑**：$A - B = A + (\text{B 的 2 的补数})$

### 3.4 二进制乘法与除法
*   **乘法**：本质是“位权展开 + 累加”。
*   **除法**：本质是“反复试商 + 减法”。
> [!IMPORTANT]
> 由于乘除法电路复杂且缓慢，计算机通常利用**加法电路配合移位运算**来模拟完成乘除。

### 3.5 移位运算 (Shift Operation)
移位是实现乘除法**最快**的方式。
*   **左移 $n$ 位**：相当于乘以 $2^n$。在右侧补 0。
*   **右移 $n$ 位**：相当于除以 $2^n$（舍弃余数）。

> **示例 (以 8 位二进制为例)**：
> *   **左移**：$0000\ 0101 (5)_{10} \ll 1 \rightarrow 0000\ 1010 (10)_{10}$
> *   **右移**：$0000\ 1100 (12)_{10} \gg 2 \rightarrow 0000\ 0011 (3)_{10}$
> **组合实战**：$x \cdot 10 = (x \ll 3) + (x \ll 1)$

---

## ⚡ 4. 逻辑运算：计算机的决策基础

### 4.1 基本逻辑门
<div align="center">

| 运算名称 | 符号 | 判别规则 |
| :--- | :---: | :--- |
| **与 (AND)** | $A \cdot B$ | 全真才为真（有 0 即 0）。 |
| **或 (OR)** | $A + B$ | 有真即为真（有 1 即 1）。 |
| **非 (NOT)** | $\overline{A}$ | 结果完全取反。 |
| **异或 (XOR)** | $A \oplus B$ | **不相同时为真**（唱反调）。 |

</div>

<p align="center"><img src="Image/Logic%20Gates.png" alt="逻辑门" width="500"></p>

### 4.2 布尔代数精要
*   **德摩根定律**：$\overline{A \cdot B} = \overline{A} + \overline{B}$ ； $\overline{A + B} = \overline{A} \cdot \overline{B}$
*   **分配定律**：$A \cdot (B + C) = (A \cdot B) + (A \cdot C)$

---

## 🛠️ 5. 硬件实现：加法器电路 (Adder)

*   **半加法器 (Half Adder)**：相加两个 1 位数。和 $S = A \oplus B$，进位 $C = A \cdot B$。
    <p align="center"><img src="Image/Half%20Adder.png" alt="半加法器" width="500"></p>
*   **全加法器 (Full Adder)**：在半加器基础上支持**进位输入 (Cin)**。

<p align="center"><img src="Image/Full%20Adder.png" alt="全加法器" width="500"></p>

---

## ⚠️ 6. 进阶应用与计算误差

### 6.1 位掩码 (Bit Masking)
*   **提取特定位**：用 **AND** 运算（掩码位设为 1）。
*   **翻转特定位**：用 **XOR** 运算（掩码位设为 1）。

### 6.2 各种计算误差
<div align="center">

| 误差名称 | 核心特征 |
| :--- | :--- |
| **溢出 (Overflow)** | 结果超限。正+正=负 或 负+负=正 时必溢出。 |
| **舍入误差** | 无法用二进制精确表示 $0.1$ 等小数导致的截断。 |
| **信息丢失** | 大数加极小数，导致小数位被忽略。 |
| **精度缺失** | 两个极其接近的数相减，导致有效位数剧减。 |

</div>

---