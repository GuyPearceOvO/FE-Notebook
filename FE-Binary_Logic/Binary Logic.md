# 计算机理论核心：二进制与逻辑运算

## 1. 引言：为何需要学习二进制？

计算机的电路系统只能识别两种最基本的状态：**开 (ON)** 和 **关 (OFF)**。这就像一个电灯，要么亮着，要么熄灭，不存在中间状态。

为了进行计算和处理信息，我们将这两种状态与数字进行了对应：

* **1** 代表 **开 (ON)**
* **0** 代表 **关 (OFF)**

通过大量开关的组合，计算机可以表达无限的信息。这种仅使用 0 和 1 两个符号来表示所有信息的系统，就是 **二进制 (2進数 / にしんすう)**。

### 核心单位

* **比特 (Bit / ビット)**：计算机处理信息的最小单位。
* **字节 (Byte / バイト)**：由 8 个比特组成的基本单位（1 Byte = 8 Bit）。

---

## 2. 数字系统：计算机的语言

### 2.1. 核心概念

任何一种数字进制系统都由三个核心概念构成：

* **基数 (基数 / きすう)**：一个数位上可以使用的数字符号个数（如十进制基数为 10）。
* **位权 (重み / おもみ)**：指数位所代表的大小，是基数的幂。
* **进位 (繰り上がり / くりあがり)**：当一个数位上的值达到基数时，向更高一位进一的过程（逢十进一）。

### 2.2. 常用进制系统对比

| 进制系统 | 基数 | 使用符号 | 应用场景 |
| :--- | :--- | :--- | :--- |
| **二进制** | 2 | 0, 1 | 计算机内部数据处理的基础，对应电路开关状态。 |
| **八进制** | 8 | 0, 1, ..., 7 | 简化二进制表示（2³ = 8），每 3 位二进制对应 1 位八进制。 |
| **十进制** | 10 | 0, 1, ..., 9 | 人类日常生活计数。 |
| **十六进制** | 16 | 0-9, A-F | 目前常用的二进制简化表示法（2⁴ = 16），每 4 位二进制对应 1 位十六进制。 |

---

## 3. 基数转换：不同进制间的“翻译”

### 3.1. 任意进制 → 十进制

**方法**：将每一位数字乘以其对应的位权，然后相加。
> **示例 1 (二进制)**：$(1011)_2 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = 8 + 0 + 2 + 1 = (11)_{10}$
>
> **示例 2 (十六进制)**：$(2A)_{16} = 2 \times 16^1 + 10 \times 16^0 = 32 + 10 = (42)_{10}$
> （注：十六进制中 A = 10，位权是 16 的幂）

### 3.2. 十进制 → 任意进制

*   **整数部分**：**除基取余法**（反复除以基数，直到商为 0，余数**逆序**排列）。
*   **小数部分**：**乘基取整法**（反复乘以基数，直到小数部分为 0 **或达到所需精度**，整数部分**顺序**排列）。

> **示例 1：十进制转二进制 $(10.125)_{10}$**
>
> 1.  **整数 (10)**： $10 \div 2 = 5 \dots 0, 5 \div 2 = 2 \dots 1, 2 \div 2 = 1 \dots 0, 1 \div 2 = 0 \dots 1$ → $(1010)_2$
> 2.  **小数 (0.125)**： $0.125 \times 2 = 0.25 (0), 0.25 \times 2 = 0.5 (0), 0.5 \times 2 = 1.0 (1)$ → $(.001)_2$
> **结果**：$(1010.001)_2$

> **示例 2：十进制转十六进制 $(182)_{10}$** (整数转换)
>
> 1.  $182 \div 16 = 11 \dots \mathbf{6}$
> 2.  $11 \div 16 = 0 \dots \mathbf{11}$ (注：十六进制中 11 记为 **B**)
> **结果**：将余数逆序排列得 $(B6)_{16}$

> **示例 3：无法除尽的情况 $(0.275)_{10}$ 转二进制**
>
> 1.  $0.275 \times 2 = \mathbf{0}.55, \quad 0.55 \times 2 = \mathbf{1}.1, \quad 0.1 \times 2 = \mathbf{0}.2 \dots$ (开始循环)
> **结果**：$(0.0100011\dots)_2$
> **注意**：并非所有十进制小数都能化为有限二进制小数。若无法乘到 0，需根据精度要求截断，这便产生了**舍入误差 (丸め誤差)**。

### 3.3. 2/8/16 进制快速转换

由于 $8=2^3$ 且 $16=2^4$，可以直接分组转换：

*   **二进制 ↔ 八进制**：每 3 位一组。
*   **二进制 ↔ 十六进制**：每 4 位一组。

> **示例：二进制 $(11010110)_2 \leftrightarrow$ 十六进制**
>
> 1.  从右往左每 4 位分组：`1101` | `0110`
> 2.  将每组独立转换：
>     *   `1101` $\rightarrow 8+4+0+1 = 13$ (即十六进制的 **D**)
>     *   `0110` $\rightarrow 0+4+2+0 = 6$ (即十六进制的 **6**)
> 3.  合并结果：$(D6)_{16}$

---

## 4. 二进制运算：计算机的计算方法

### 4.0. 类型区分：无符号 vs 有符号

在进行运算前，必须明确数据的表现形式：

*   **无符号数 (符号なし)**：所有位都表示数值，范围从 $0$ 到 $2^n-1$。
*   **有符号数 (符号あり)**：使用 **符号位 (Sign Bit)** 来表示正负。
    *   **位置**：最高位（最左侧的一位）。
    *   **规则**：`0` 为正 (+)，`1` 为负 (-)。
    *   **存储**：负数在计算机中统一使用 **补码** 形式存储。

> **关键特性**：使用补码后，符号位可以像数值位一样参与加法运算，极大地简化了硬件设计。

### 4.1. 二进制加法

遵循“逢二进一”规则：
* $0 + 0 = 0$
* $0 + 1 = 1$
* $1 + 0 = 1$
* $1 + 1 = 10 \quad$（本位 0，进位 1）

> **示例：有符号数补码运算 $5 + (-3)$**
> 1.  **5 的补码**：`0000 0101`
> 2.  **-3 的补码**：`1111 1101` (由 3 取反加 1 得到)
> 3.  **相加**：
>     ```text
>        0000 0101 (5)
>      + 1111 1101 (-3)
>      -----------
>      (1)0000 0010 (结果为 2，进位丢弃)
>     ```
> **结论**：符号位直接参与运算，无需额外逻辑判断。

### 4.2. 二进制减法与补数 (Complement)

计算机内部为了精简电路，没有专门的减法电路。减法是通过将减数转换为 **补数 (補数 - ほすう)** 后，进行 **加法** 运算实现的。

*   **原码 (Sign-Magnitude)**：最直观的表示法（最高位符号位，其余数值位）。
*   **1 的补数 (1's Complement)**：对应中文的 **“反码”**。将二进制位逐位取反。
*   **2 的补数 (2's Complement)**：对应中文的 **“补码”**。在反码基础上 **加 1**。本质就是原码的相反数（比如（8）的补码是-8）

> **核心逻辑**：$A - B = A + (\text{B 的 2 的补数})$
> **意义**：统一了加减法运算，使 CPU 只需 **加法器** 即可处理减法，并解决了“正负零”不统一的问题。

### 4.3. 二进制乘法与除法

二进制的乘除法逻辑与十进制手工计算非常相似，但因为只有 0 和 1，所以更简单。

*   **乘法**：本质是“**位权展开 + 累加**”。
    *   例如：$5 \times 3 \rightarrow (101)_2 \times (11)_2$。相当于 $(101 \times 1) + (101 \times 10)$。
*   **除法**：本质是“**反复试商 + 减法**”。

> **重要结论**：由于乘除法电路实现非常复杂且缓慢，计算机通常利用 **加法电路** 配合 **移位运算** 来模拟完成乘除。

### 4.4. 移位运算 (Shift Operation) - 乘除法的提速工具

移位是计算机中**实现乘除法最快的方式**（比直接乘除指令快得多）。

#### 1. 核心原理
*   **左移 $n$ 位**：相当于乘以 $2^n$。在右侧补 0。
*   **右移 $n$ 位**：相当于除以 $2^n$（舍弃余数）。

#### 2. 示例 (以 8 位二进制为例)
*   **左移**：$0000\ 0101 (5)_{10} \ll 1 \rightarrow 0000\ 1010 (10)_{10}$
*   **右移**：$0000\ 1100 (12)_{10} \gg 2 \rightarrow 0000\ 0011 (3)_{10}$
*   **组合应用**：$x \times 10 = (x \ll 3) + (x \ll 1)$

---

## 5. 逻辑运算：计算机的决策基础

### 5.1. 基本逻辑门

| 运算名称 | 符号 | 说明 | 真值表简述 |
| :--- | :---: | :--- | :--- |
| **与 (AND)** | $A \cdot B$ | 两者皆真才为真。 | $1 \text{ AND } 1 = 1$，其余为 0。 |
| **或 (OR)** | $A + B$ | 只要一方为真即为真。 | $0 \text{ OR } 0 = 0$，其余为 1。 |
| **非 (NOT)** | $\overline{A}$ | 结果完全取反。 | $\text{NOT } 1 = 0, \text{NOT } 0 = 1$。 |

![逻辑门](Image/Logic%20Gates.png)

### 5.2. 组合逻辑门

* **与非 (NAND)**：AND 结果取反。
* **或非 (NOR)**：OR 结果取反。
* **异或 (XOR)**：**不相同时为 1**（唱反调电路）。

### 5.3. 布尔代数精要

* **德摩根定律**：$\overline{A \cdot B} = \overline{A} + \overline{B}$ ； $\overline{A + B} = \overline{A} \cdot \overline{B}$
* **分配定律**：$A \cdot (B + C) = (A \cdot B) + (A \cdot C)$

---

## 6. 加法器电路 (Adder)

### 6.1. 半加法器 (Half Adder)

对两个 1 位二进制数相加：

* **和 (Sum)**：$S = A \text{ XOR } B$
* **进位 (Carry)**：$C = A \text{ AND } B$
* *局限性：无法处理低位的进位输入。*

![半加法器](Image/Half%20Adder.png)

### 6.2. 全加法器 (Full Adder)

在半加法器基础上，支持 **进位输入 (Cin)**。由两个半加法器和一个 OR 门组成。

![全加法器](Image/Full%20Adder.png)

---

## 7. 进阶概念与应用

### 7.1. 位掩码 (Bit Masking)

* **提取特定位**：用 **AND** 运算（掩码位设为 1）。
* **翻转特定位**：用 **XOR** 运算（掩码位设为 1）。

### 7.2. 计算误差与溢出

*   **溢出 (Overflow / 溢れ - あふれ)**：结果超出了容器能表达的范围。
    *   **无符号溢出**：观察 **最高位是否产生进位 (Carry Out)**。
    *   **有符号溢出**：观察 **符号位的逻辑合理性**。
        *   正 + 正 = 负 (0 + 0 = 1) $\rightarrow$ 溢出
        *   负 + 负 = 正 (1 + 1 = 0) $\rightarrow$ 溢出
        *   *提示：一正一负相加永远不会产生补码溢出。*
    *   **STEP1:** 把所有位都当成数值直接相加。
    *   **STEP2:** 加完之后，一定要根据题目要求的**“数据类型”**来检查结果   
*   **其他误差**：
    *   **舍入误差 (丸め誤差)**：如 $0.1$ 无法用二进制精确表示导致的截断。
    *   **信息丢失 (情報落ち)**：大数加极小数，导致小数位被忽略（指数部分差太大）。
    *   **精度缺失 (桁落ち)**：两个极其接近的数相减，导致有效数字位数剧减。

---
> [!NOTE]
> 本笔记整理自计算机基础理论核心考点。
